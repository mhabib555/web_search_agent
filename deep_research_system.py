import asyncio
import json
from agents import Runner, SQLiteSession, ItemHelpers
from aiagents.information_gathering_agent import information_gathering_agent
from config.context import UserContext
from config.fake_data import fake_users
import logging

# Configure logging for error handling
logging.basicConfig(level=logging.ERROR, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Initialize SQLite session for storing research data
try:
    session = SQLiteSession("deep_research")
except Exception as e:
    logger.error(f"Failed to initialize SQLite session: {str(e)}")
    raise

async def main():
    try:
        # Select user context from fake_users data
        user_index = 1
        if user_index >= len(fake_users):
            raise IndexError("Invalid user index")
        user_context = UserContext(
            name=fake_users[user_index]['name'],
            city=fake_users[user_index]['city'],
            topic=fake_users[user_index]['topic'],
            subscription=fake_users[user_index]['subscription']
        )

        while True:
            try:
                print("\n================ Deep Research System ================")
                sample_query = "How did the adoption of server-side rendering with Next.js improve page load times and SEO rankings for any common e-commerce websites?"
                print(f"Type enter to query: {sample_query}")
                print("Type 'exit' to quit.")
                user_input = input("\nEnter your research query: ").strip()

                if user_input.lower() == 'exit':
                    break
                elif user_input == "":
                    user_input = sample_query  # Use default query if input is empty
                    print(f"Searching for default query: {user_input}")

                # Run Information Gathering Agent
                print("\nRunning Information Gathering Agent...")
                response = Runner.run_streamed(
                    starting_agent=information_gathering_agent,
                    input=user_input,
                    context=user_context,
                    max_turns=12,
                    session=session
                )

                final_report = ""
                last_agent = ""
                async for event in response.stream_events():
                    if event.type == "agent_updated_stream_event":
                        last_agent = event.new_agent.name
                        continue
                    elif event.type == "run_item_stream_event":
                        if event.item.type == "message_output_item":
                            final_report = ItemHelpers.text_message_output(event.item)
                            print(f"\n\n[{last_agent}] Response: {final_report}...")
                        elif event.item.type == "tool_call_output_item":
                            try:
                                tool_output = json.loads(event.item.output)
                                print(f"Tool output: {tool_output}")
                            except json.JSONDecodeError as je:
                                logger.error(f"Failed to parse tool output: {str(je)}")
                                print("Failed to parse tool output")

                # Print final report if generated by ReportWriterAgent
                if final_report and last_agent == "ReportWriterAgent":
                    print(f"\n\n\n================================")
                    print(f"\n=== {last_agent} Research Report ===\n")
                    print(final_report)
                    print("\n=== End of Report ===\n")

            except KeyboardInterrupt:
                logger.info("User interrupted the process")
                break
            except Exception as e:
                logger.error(f"Error in main loop: {str(e)}")
                print(f"Error: {str(e)}")
                continue  # Continue loop to allow new queries

    except IndexError as ie:
        logger.error(f"User context error: {str(ie)}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in main: {str(e)}")
        raise

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except Exception as e:
        logger.error(f"Error running asyncio: {str(e)}")
        raise